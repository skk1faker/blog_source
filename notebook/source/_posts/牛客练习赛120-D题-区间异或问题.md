---
title: 牛客练习赛120-D题-区间异或问题
date: 2024-01-15 10:56:12
tags: 
- acm
- xor
- 异或
---

# 题意
存在序列`a[i]`, 至多k次改动，每次改动可以将第i个元素+1，即`a[i] = a[i] + 1`，问，怎样安排改动可以使得序列的区间和为奇数的区间数量最多。

# 题解

在给出题解之前，需要有一些预备知识：

1. 简单来说，计算奇偶与异或有关
    计算区间和为奇数与异或有关，设`b[i] = a[i] % 2`，则区间`[l,r]`内`a[i]`和奇偶性与`b[i]`的异或和一样，所以将问题简化，直接计算`b`的异或前缀和`pre_xor`即可。
2. 异或前缀和$pre\_xor[i] = b[0] \oplus b[1] \oplus \dots b[n]$，则区间[l,r]异或和为$pre\_xor[l - 1] \oplus pre\_xor[r]$。
    所以一个区间的异或和为奇数，那么参与计算的两个$pre\_xor[i]$不相等即可。

根据以上知识可以知,只要改动中令$pre\_xor$的01数量均衡，就可以让奇数和区间增多（原因很简单，假设总共n个数，异或前缀和中有m个1，n + 1 - m个0 (前缀和中存在一个pre\_xor不包含任意一个元素)，则奇数和区间数量为(n - m + 1) * m个，这是二次函数，求最值即可）,已知将i位置操作会发生`a[i] = a[i] + 1`，相应的b[i]相当于与1进行了异或，pre\_xor会在[i,n + 1]区间内所有值从0变为1。前面分析如果想让奇数和区间数量变为最大值，可以使pre\_xor中01数量均匀。这种操作只需要一次就能完成，现给出证明。

先将问题抽象为“给出任意个01序列x，存在一种操作能将`[i,n]`01翻转，请找出这个位置，使得0的数量和1的数量差距最小”。

先计算所有x中所有1的数量，然后从最后一个位置逐个向0位置进行01翻转，计算此时数列中1的数量，在每次进行01翻转时，1的数量只能增加1或减少1，是**连续**的，假设未经翻转前1的数量为k个（0数量与1数量差距为n-2k），那么全部翻转完1的数量应为n - k个（01数量差距为2k - n)，由于之中要寻找01数量差距为1或为0的位置，因为\|$n - 2k\| >= 0$，n-2k与2k-n异号，01数量差距曲线必穿越x轴。每次翻转后01数量变化为+2 或-2，所以当n为偶数时必有一个时刻数量差为0，当n为奇数的时候必有一个时刻数量差为1或-1。

```cpp
/*================================================================
*   Copyright (C) 2024 Wangxinpeng. All rights reserved.
*   
*   filename：    D.cpp
*   username:     skt1faker
*   create time:  20:24  2024.01.14
    email:        skk1faker@163.com
*   descripe:     
*
================================================================*/

#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define DEBUG0
const int mod1 = 1e9 + 7;
const int mod2 = 998244353;

const int maxx = (int)2e5 + 10;
int pre_xor[maxx];
int b[maxx];

int main()
{
  int T;
  cin>>T;
  while(T--){
    ll n,k;
    cin>>n>>k;
    pre_xor[0] = 0;
    ll sum = 0;
    for(int i = 1;i <= n;i++){
      scanf("%d",&b[i]);
      b[i] %= 2;
      pre_xor[i] = pre_xor[i - 1] ^ b[i];
      sum += pre_xor[i];
    }
    if(k == 0){
      cout << sum * (n + 1 - sum)<<endl;
    }
    else {
      cout<<(n + 1) / 2 * ((n + 1) - (n + 1) / 2)<<endl;
    }
  }
}

```
