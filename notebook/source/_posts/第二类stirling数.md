---
title: 第二类stirling数
tags:
  - 数学
  - acm
date: 2024-05-08 14:44:38
---


# 第二类stirling数定义

第二类stirling用于表示n个元素为k个集合中有多少种分法。例如3个元素分到2个集合中可以有`[{1,2},{3}],[{1},{2,3}],[{1,3},{2}]`三种分配方案。将这类数记作`S(n,k)`。

`S(n,k)`满足递推表达式，如果一些题目中能够得到如下表达式可直接套用`S(n,k)`的通项。

$$ S(n,k) = S(n - 1, k - 1) + k\times S(n - 1,k) $$
递推式证明如下：  

按照最后一个元素的分配情况来看，可分为两种情况：  
1. 最后一元素不与其他元素成为一个集合，即最后一个元素单独成为一个集合

这种情况前面`n - 1`个元素划分为`k - 1`个集合，最后一个元素 单独成为一个集合，种类数为`S(n - 1,k - 1)`

2. 最后一个元素与其他元素成为一个集合

这种情况前面`n - 1`个元素划分为`k`个集合，最后一个元素选择一个加入进去就行。故种类数为$C_{k}^{1}S(n - 1,k)$

上述表达式使用生成函数难以得到通项，但可使用容斥原理计算通项。

# 容斥原理计算通项

把集合视为盒子，假设每个盒子不同，n个元素分到k个盒子里且盒子不为空的种类数应与原问题的种类数相差$k!$倍。设$f_{i}$为一类条件，表示盒子i不为空。则原问题是在求$\bigcap_{i = 1}^{k} f_{i} = U - \bigcup_{i = 1}^{k}\bar{f_{i}}$，全集$U = \bigcup_{i = 1}^{k}f_{i} \cup \bar{f_{i}}$，故$|U| = k^{n}$， 即每个元素有k个选择方案。对于|\bigcup_{i = 1^{k}\bar{f_{i}}}|的计算上可使用容斥原理。

$\bar{f_{i}}$表示只有第i个箱子为空**其他的任意**（注意不是其他的不为空），所以计数值如下：
$$
|\bar{f_{i}}| = (k - 1)^{n}
$$

$\bar{f_{i}} \cap \bar{f_{j}}$表示第i与j箱子为空其他任意，所以计数值为:

$$
|\bar{f_{i}} \cap \bar{f_{j}}| = (k - 2)^{n}
$$
故$\sum_{i = 1}^{k} |\bar{f_{i}}| = C_{k}^{1}(k - 1)^{n}$，$\sum_{i < j}^{i<=k,j<=k}|\bar{f_{i}}\cap\bar{f_{j}}| = C_{k}^{2}(k - 2)^{n}$依此类推，可以得到

$$
\begin{matrix}
|U - \bigcup_{i = 1}^{k}\bar{f_{i}}| &=& n^{k} - (C_{k}^{1}(k - 1)^{n} - C_{k}^{2}(k - 2)^{n} + (-1)^{i + 1}C_{k}^{i}(k - i)^{n} + (-1)^(k + 1)C_{k}^{k}(0)^{n}) \\ &=& \sum_{i = 0}^{k}(-1)^{i}C_{k}^{i}(k - i)^{n};
\end{matrix}
$$
消除盒子不同导致的差异，可得$S(n,k) = \frac{1}{k!}\sum_{i = 0}^{k}(-1)^{i}C_{k}^{i}(k - i)^{n}$，**注意式子中i从0开始**

# 结论

如果组合数f(n,k)满足：  
$f(n,k) = f(n-1,k-1) + k f(n - 1,k)$  
则$f(n,k) = \frac{1}{k!}\sum_{i = 0}^{k}(-1)^{i}C_{k}^{i}(k - i)^n$，如记$j = k - i$，则$i = k - j$，表达式可写为$\frac{1}{k!}\sum_{j = k}^{0}(-1)^{k - j}C_{k}^{j}(j)^n$

# 例题 洛谷P6162 [Cnoi2020] 四角链

有$n - 1$个格子，每个格子编号为$1、2、3......n - 1$，现对每个格子填数，每个格子有以下要求：

1.  格子可以不填数
2.  格子可以填入小于等于自己编号的数
3.  任意两个格子不能填相同的数

如果令k个格子填入数字，那么有多少种填法。

## 题解

首先可以得出一个递推式，n - 1个格子，填k个数的填法为T(n,k)中方案，那么根据最后一个格子的填数方案，则有最后一个格子填数和不填数两种方案。（由于要写递推式，形式为前n - 1个格子由前n - 2个格子的情况推出，所以先假设前n - 2个格子都安排好了，这样在安排过程中条件宽松。可以尝试先安排最后一个格子的数，可以发现最后一个格子可以填n - 1个数，但是无法得到前n - 2个元素的安排方案。可以总结出，先处理要求条件高的）。

1. 最后一个格子不填数，则前n - 2个格子中有k个格子要填数，且n - 1无法填入前n - 2个格子中，故种类数为T(n - 1,k)

2. 最后一个格子填数，则可填数字有n - 1个，但前n - 2个格子填数种类可能会收到限制。故先考虑前n - 2个格子填k - 1个数，剩下的n - 1 - (k - 1)个可用数字填在最后一个格子中，故方案数为$(n - k) T(n - 1,k - 1)$

最终得到
$$
T(n,k) = (n - k) T(n - 1,k - 1) + T(n - 1, k)
$$

将$T(n,k)$替换为$S(n,n - k)$，则有$T(n - 1,k - 1) = S(n - 1,n - 1 - (k - 1))$, $T(n - 1,k) = S(n - 1, n - 1 - k)$

$$
S(n, n - k) = (n - k)S(n - 1,n - k) + S(n - 1,n - k - 1)
$$

S(n,k)递推式满足第二类stirling递推式，故答案为S(n,n - k);

```cpp
/*================================================================
*   Copyright (C) 2024 Wang XinPeng. All rights reserved.
*   
*   filename:     p6162.cpp
*   username:     skt1faker
*   create time:  10:23  2024.05.09
*   modify time:  10:23  2024.05.09
*   email:        skk1faker@163.com
*   descripe:     
*
================================================================*/

#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define lll __int128
#define DEBUG0
const int mod1 = 1e9 + 7;
const ll mod2 = 998244353;
ll pow_(ll a, ll b = mod2 - 2){
  ll ans = 1;
  while(b){
    if(b & 1)ans = (ans *  a) % mod2;
    b /= 2;
    a = (a * a) % mod2;
  }
  return ans;
}

ll get_ans(ll n,ll k){
  ll ans = 0;
  ll C = 1;
  for(ll i = 1;i <= k;i++){
    C = (((C * (k - i + 1)) % mod2) * pow_(i)) % mod2;
    if((k - i) & 1 )ans = (ans + (mod2 - ((C * pow_(i,n)) % mod2)) % mod2) % mod2;
    else ans = (ans + (C * pow_(i,n)) % mod2) % mod2;
  }
  for(ll i = 1;i <= k;i++){
    ans = (ans * pow_(i)) % mod2;
  }
  return ans;
}

int main()
{
  ll n,k;
  cin>>n>>k;

  cout<<get_ans(n,n - k)<<endl;
  return 0;
}


```

# 参考资料

[参考资料，第二类stirling数](https://www.bananaspace.org/wiki/%E7%AC%AC%E4%BA%8C%E7%B1%BB_Stirling_%E6%95%B0)  

{% post_link 容斥原理 本站容斥原理 %}


