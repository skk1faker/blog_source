---
title: dp计数状态的确定
tags:
  - dp
date: 2025-03-06 21:51:21
---


# 计数问题

计算计数问题有多种方案,一种是直接使用数学表达式,另一种是使用dp, 数学表达式直接通过推到即可得出,本文主要讨论dp情况.

多个dp状态不可对应于某一个计数状态.这样会导致计数数量较多, 我们看一个例子

## 题意

给n男m女,问有多少种排列方法,使得排列后任取一段排列其中的男女数量差不会超过k, 其中$n,m < 150, k < 20$

## 题解

如果使用计数方法似乎不太容易, 无论正向思考还是反向思考似乎都无法得到正确答案.

考虑dp方法,题目中要求计算`任意一段区间`情况, 这种情况可以考虑状态中存在`最后一个位置的情况`以及`当前序列长度`, 通过枚举最后一个位置的情况,计算以最后一个位置为右端点的所有区间, 计算完所有序列长度后,即可得满足`任意一段区间`的相关性质.  

### 一个错误的接法

如果已知`当前序列使用男生x,女生y`和`后缀最的男女差值i`,以及最大差值是`男多还是女多j`,那么dp转移方程如下:

$$
dp[x][y][i][j] = dp[x][y - 1][i - 1][j] + dp[x - 1][y][i][j]
$$

当然还需要考虑$i == 0$时是通过$j = 0$还是$j == 1$变化得来(男女数量均衡是通过男多于女还是女多余男的情况变化过来)

先说下这个中情况的错误之处,原因是一种情况可能会在两个dp中被计数,例如序列`nnvnv`, 在$dp[3][2][1][0]$和$dp[3][2][1][1]$各被记录一次,会导致最终答案数量不正确.

### 正解

正解就是在错解上改正,上面说到只记录`男生多于女生最大值和`和`女生多余男生最大值`无法准确描述一个状态,所以我们在状态中将两个最大值均记录下来, 注意这个最大值不会小于0, 因为一个后缀里没有元素时差值为0,所以两者插值最大值最小为0,不会出现负数.


转移过程应考虑男女生变化:

一个长$i$的序列后缀中,记男 - 女最值为$MW_{i}$(man - woman), 女 - 男最大值为$WM_{i}$

由于女生和男生变化对称.故只考虑男生数量变化, 已知后缀序列选择为空时值为男女差值为0,所以$MW_{i}, WM_{i}$最小为0, 也正是这个原因,才产生了分类讨论的问题.

当男生增加一个时, 可能会导致:

1. $WM_{i + 1} = WM_{i} - 1$ , $MW_{i + 1} = MW_{i} + 1$
增加一个男生对所有原后缀状态都出现 +1,-1的影响,故最大值也为相应的+1 -1的影响.

2. $WM_{i + 1} == WM_{i} = 0$ , $MW_{i + 1} = MW_{i} + 1$  此状态为上述$WM_{i}$持续保持为0的原因

于是根据上述描述可进行状态转移方成的书写. 

### 状态转移方程

假设$dp[i][j][x][y]$为i个男生,j个女生,$MW_{i} = x, WM_{i} = y$,我们从两个角度考虑转移方成.


#### 1. $dp[i][j][x][y]$能变成谁

这种思考方式使符合序列生成过程,所以更容易得到答案.

根据上术增加男生的讨论,我们可以得出以下的式子.

1. if($WM_{i} != 0$) ==> $WM_{i + 1} = WM_{i} - 1$ , $MW_{i + 1} = MW_{i} + 1$

```cpp
if(y != 0)
    dp[i + 1][j][x + 1][y - 1] += dp[i][j][x][y]
```

2. if($WM_{i} = 0$) ==> $WM_{i + 1} == WM_{i}, MW_{i + 1} = MW_{i} + 1$  

```cpp
if(y == 0)
    dp[i + 1][j][x + 1][y] += dp[i][j][x][y]
```

将上述两种情况合并可得到:

```cpp
    dp[i + 1][j][x + 1][max(0,y - 1)] += dp[i][j][x][y];
```
对称的,女生也可得如下表达式:
```cpp
    dp[i][j + 1][max(0,x - 1)][y + 1] += dp[i][j][x][y];
```
#### 2. $dp[i][j][x][y]$由谁变来

这种方式留给读者思考,需要注意的是x在增加男生和增加女生后会如何变化.

可以确定的是,增加女生一定会导致y的增加,但是不一定会导致x增加,需要讨论x是否为0,转移方程如下:

```cpp

if(i == 0 || j == 0){
    if((i == 0 && x == 0 && j == y) || (j == 0 && y == 0 && i == x))
        dp[i][j][x][y] = 1;
    continue;
}
if(x == 0 && y == 0)
    continue;
    dp[i][j][x][y] = ((x - 1 < 0 ? 0: dp[i - 1][j][x - 1][y + 1]) + (y - 1 < 0 ? 0 : dp[i][j - 1][x + 1][y - 1]));
    if(x == 0){
        // 0 可由两种状态得到,原先n-v == 0,新加如一个女,另一种就是男 - 女 = 1,新加入一个女
        dp[i][j][x][y] += dp[i][j - 1][x][y - 1];
    }
if(y == 0){
    dp[i][j][x][y] += dp[i - 1][j][x - 1][y];
}
```

## 完整代码如下

```cpp

/*================================================================
*   Copyright (C) 2025 Wang XinPeng. All rights reserved.
*   
*   filename:     p2592.cpp
*   username:     skt1faker
*   create time:  13:30  2025.02.23
*   modify time:  13:30  2025.02.23
*   email:        skk1faker@163.com
*   descripe:     
*
================================================================*/

#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define lll __int128
#define DEBUG0
#define L(x) (x << 1)
#define R(x) (L(x) + 1)
const int mod1 = 1e9 + 7;
const int mod = 12345678; 
const int maxn = 150 + 10;
//int dp[maxn][maxn][30][2];	// 男,女,,0 -- 男女, 1 -- 女男		//此状态不可行,因为一个序列状态可能在多个dp中,例如序列(男), 在dp[1][0][1][0] = 1, dp[1][0][0][1] = 1,这样显然不可行,显然需要将两个状态放在一起.

int dp[maxn][maxn][30][30];
int main()
{
	int n,m,k;
	cin>>n>>m>>k;
	memset(dp,0,sizeof(dp));
	dp[0][0][0][0] = 1;
	for(int i = 0;i <= n;i++){
		for(int j = 0;j <= m;j++){
			for(int x = 0;x <= k;x++){
				for(int y = 0;y <= k;y++){
#if 0
					dp[i + 1][j][x + 1][max(0,y - 1)] += dp[i][j][x][y];	// 新增一个男生
					dp[i][j + 1][max(x - 1, 0)][y + 1] += dp[i][j][x][y]; 	// 新增一个女生, 注意使用max函数的原因,因为无论(男 - 女)还是(女 - 男),最后一个位置他们的值都是0,所以这个差值最大值不可能为负数
					dp[i + 1][j][x + 1][max(0,y - 1)] %= mod;	// 新增一个男生
					dp[i][j + 1][max(x - 1, 0)][y + 1] %= mod ; 	// 新增一个女生
#else
					if(i == 0 || j == 0){
						if((i == 0 && x == 0 && j == y) || (j == 0 && y == 0 && i == x))
							dp[i][j][x][y] = 1;
						continue;
					}
					if(x == 0 && y == 0)
						continue;
					dp[i][j][x][y] = ((x - 1 < 0 ? 0: dp[i - 1][j][x - 1][y + 1]) + (y - 1 < 0 ? 0 : dp[i][j - 1][x + 1][y - 1]));
					if(x == 0){
						// 0 可由两种状态得到,原先n-v == 0,新加如一个女,另一种就是男 - 女 = 1,新加入一个女
						dp[i][j][x][y] += dp[i][j - 1][x][y - 1];
					}
					if(y == 0){
						dp[i][j][x][y] += dp[i - 1][j][x - 1][y];
					}
					dp[i][j][x][y] %= mod;
#endif
				}
			}
		}
	}
	int ans = 0;
	for(int x = 0;x <= k; x++){
		for(int y = 0;y <= k;y++){
			ans = (ans+ dp[n][m][x][y]) % mod;
		}
	}
	cout<<ans<<endl;
    return 0;
}
```

